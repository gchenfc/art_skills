/* ----------------------------------------------------------------------------

 * GTSAM Copyright 2010, Georgia Tech Research Corporation,
 * Atlanta, Georgia 30332-0415
 * All Rights Reserved
 * Authors: Frank Dellaert, et al. (see THANKS for the full author list)

 * See LICENSE for the license information

 * -------------------------------------------------------------------------- */

/**
 *  @file  testAvoidIndeterminateLinSys.cpp
 *  @author Juan-Diego Florez
 *  @author Gerry Chen
 **/

#include <CppUnitLite/TestHarness.h>
#include <gtsam/base/Vector.h>

#include <vector>

#include "../SlnStrokeExpression.h"
#include "../SlnStroke.h"

// We will also try this using an expression factor graph:
#include <gtsam/nonlinear/ExpressionFactorGraph.h>
#include <gtsam/slam/expressions.h>

// Each variable in the system (poses and landmarks) must be identified with a
// unique key. We can either use simple integer keys (1, 2, 3, ...) or symbols
// (X1, X2, L1). Here we will use Symbols
#include <gtsam/inference/Symbol.h>

// Finally, once all of the factors have been added to our factor graph, we will
// want to solve/optimize to graph to find the best (Maximum A Posteriori) set
// of variable values. GTSAM includes several nonlinear optimizers to perform
// this step. Here we will use the common Levenberg-Marquardt solver
#include <gtsam/nonlinear/LevenbergMarquardtOptimizer.h>
// Should the LM optimizer fail, we will use the GaussNewton optimizer, as it
// will error out if the system is indeterminate.
#include <gtsam/nonlinear/GaussNewtonOptimizer.h>

// Once the optimized values have been calculated, we can also calculate the
// marginal covariance of desired variables
#include <gtsam/nonlinear/Marginals.h>

using namespace std;
using namespace gtsam;
using namespace art_skills;

TEST(ExpressionSlnFactor, ILS) {
  // 1. Create a factor graph container and add factors to it
  ExpressionFactorGraph graph;

  // Matrix for t, x, y, reference for each position factor
  // TODO: import data from csv file generated by python script
  Eigen::Matrix<double, 31, 3> data1;
  data1 << 0.000000000000000000e+00,3.254897368664543267e-01,-8.936601621630331227e-01, //
8.333333333333300258e-03,3.269525745636264746e-01,-8.900745220853243378e-01, //
1.666666666666660052e-02,3.291453697577698678e-01,-8.852161029552397808e-01, //
2.499999999999990077e-02,3.325515378590233051e-01,-8.787672389395526640e-01, //
3.333333333333320103e-02,3.359679291751946351e-01,-8.703859355971451661e-01, //
4.166666666666650476e-02,3.399923931724491144e-01,-8.602826055064219934e-01, //
4.999999999999980155e-02,3.442824786600893194e-01,-8.480163473642363670e-01, //
5.833333333333309834e-02,3.491627944160899943e-01,-8.333700759417705939e-01, //
6.666666666666640206e-02,3.539444568538996361e-01,-8.171722977308741864e-01, //
7.499999999999970579e-02,3.592159525538891618e-01,-7.986980555707734464e-01, //
8.333333333333300952e-02,3.650546213240065674e-01,-7.787279749159550235e-01, //
9.166666666666629937e-02,3.714736542000802166e-01,-7.570136703552537982e-01, //
9.999999999999960310e-02,3.778634091460778555e-01,-7.333904140887657075e-01, //
1.083333333333329068e-01,3.843281155915927449e-01,-7.087376395403870433e-01, //
1.166666666666661967e-01,3.909623919130325032e-01,-6.824655080692988429e-01, //
1.249999999999995004e-01,3.974843175627018055e-01,-6.555879713420276200e-01, //
1.333333333333328041e-01,4.039229239569012142e-01,-6.276668544291764684e-01, //
1.416666666666661079e-01,4.105347405162689256e-01,-5.992839591518326348e-01, //
1.499999999999994116e-01,4.170243715585888467e-01,-5.709676427131310517e-01, //
1.583333333333327153e-01,4.225962714348362459e-01,-5.424340160626357488e-01, //
1.666666666666660190e-01,4.286362937160109743e-01,-5.141503176252475438e-01, //
1.749999999999992950e-01,4.343193225662036472e-01,-4.862841172426772829e-01, //
1.833333333333325987e-01,4.388840687436094123e-01,-4.590381204102663704e-01, //
1.916666666666659025e-01,4.427400928215209919e-01,-4.330911887270484373e-01, //
1.999999999999992062e-01,4.457518663108581691e-01,-4.092233080346499019e-01, //
2.083333333333325099e-01,4.483554727983301014e-01,-3.883470340886382433e-01, //
2.166666666666658136e-01,4.505788138762804040e-01,-3.709451157561682866e-01, //
2.249999999999991174e-01,4.521774015580295458e-01,-3.582143602029230767e-01, //
2.333333333333323933e-01,4.540392733371415579e-01,-3.502929538788304153e-01, //
2.416666666666656971e-01,4.553027656528993994e-01,-3.465550328228148569e-01, //
2.499999999999990008e-01,4.569055513590115636e-01,-3.463931905575849957e-01; //

  Eigen::Matrix<double, 26, 3> data2;
  data2 << 2.583333333333323045e-01,4.597726452772731287e-01,-3.480442627829090085e-01, //
2.666666666666656083e-01,4.637466414709245366e-01,-3.511420191924676804e-01, //
2.749999999999989120e-01,4.694712239202033510e-01,-3.549814288240396021e-01, //
2.833333333333322157e-01,4.778600896501850603e-01,-3.592088052046040758e-01, //
2.916666666666655194e-01,4.883024542988759764e-01,-3.639965914814113912e-01, //
2.999999999999988232e-01,5.007569016599718870e-01,-3.694741496099679390e-01, //
3.083333333333321269e-01,5.151484245725873601e-01,-3.761071136131695081e-01, //
3.166666666666654306e-01,5.305850612123014232e-01,-3.835630095099867853e-01, //
3.249999999999987343e-01,5.473633949232163953e-01,-3.924891186442278634e-01, //
3.333333333333320381e-01,5.648703455475585500e-01,-4.013361775672120713e-01, //
3.416666666666652863e-01,5.826855123717972207e-01,-4.111466170624401562e-01, //
3.499999999999985900e-01,6.002228458510880937e-01,-4.215751605844063610e-01, //
3.583333333333318937e-01,6.176110564609568199e-01,-4.327883014910600679e-01, //
3.666666666666651975e-01,6.343934379849950345e-01,-4.448959022356647752e-01, //
3.749999999999985012e-01,6.504811847326529284e-01,-4.573921175879326340e-01, //
3.833333333333318049e-01,6.658590651729233700e-01,-4.711609448990483617e-01, //
3.916666666666651087e-01,6.799793643641809382e-01,-4.858631072075896284e-01, //
3.999999999999984124e-01,6.928587089667841425e-01,-5.013580801120272046e-01, //
4.083333333333317161e-01,7.048465505846475132e-01,-5.179127578101864193e-01, //
4.166666666666650198e-01,7.149582393679007053e-01,-5.347979029017730923e-01, //
4.249999999999983236e-01,7.237916728324097493e-01,-5.525162038884621207e-01, //
4.333333333333316273e-01,7.311118922125394715e-01,-5.704550933488865549e-01, //
4.416666666666649310e-01,7.368061974258918179e-01,-5.887103193793614686e-01, //
4.499999999999982347e-01,7.412459779213161903e-01,-6.071502256470979741e-01, //
4.583333333333315385e-01,7.450023736799762375e-01,-6.252183404378520715e-01, //
4.666666666666647867e-01,7.459270263188526595e-01,-6.434319707583902037e-01;

Eigen::Matrix<double, 26, 3> data3;
data3 <<4.749999999999980904e-01,7.445173488755695290e-01,-6.615477980016800652e-01, //
4.833333333333313941e-01,7.419374014293339537e-01,-6.793448127655450364e-01, //
4.916666666666646979e-01,7.370412351621581371e-01,-6.970045267021336421e-01, //
4.999999999999980016e-01,7.300201506321386535e-01,-7.142887295936262149e-01, //
5.083333333333313053e-01,7.219249376854181000e-01,-7.311339912496037652e-01, //
5.166666666666646091e-01,7.117892162453994809e-01,-7.469003803640744676e-01, //
5.249999999999979128e-01,6.994529392618230590e-01,-7.620733822383349843e-01, //
5.333333333333312165e-01,6.850766139936886878e-01,-7.762894585786362933e-01, //
5.416666666666645202e-01,6.677796477903724659e-01,-7.897152657656122399e-01, //
5.499999999999978240e-01,6.490830583474381799e-01,-8.026452624396261948e-01, //
5.583333333333311277e-01,6.285934836485338462e-01,-8.146179823728372238e-01, //
5.666666666666644314e-01,6.064069968546460521e-01,-8.255125376144178961e-01, //
5.749999999999977351e-01,5.836823087441487257e-01,-8.352993028327988512e-01, //
5.833333333333310389e-01,5.600363157737114905e-01,-8.443976369437641294e-01, //
5.916666666666643426e-01,5.358803351758451017e-01,-8.530096463526600781e-01, //
5.999999999999976463e-01,5.117229853591865885e-01,-8.611398794314157890e-01, //
6.083333333333309501e-01,4.872673550702043554e-01,-8.677720015164376299e-01, //
6.166666666666642538e-01,4.632855210598019191e-01,-8.729843473925337216e-01, //
6.249999999999975575e-01,4.403426004831740848e-01,-8.769676589706545400e-01, //
6.333333333333308612e-01,4.176456105132382857e-01,-8.806518370229197146e-01, //
6.416666666666641650e-01,3.964020954125985208e-01,-8.841107001452181979e-01, //
6.499999999999974687e-01,3.772190326425930995e-01,-8.873507308179238162e-01, //
6.583333333333307724e-01,3.611184654846978370e-01,-8.906099135554215174e-01, //
6.666666666666640761e-01,3.487563389087554588e-01,-8.933966858458401994e-01, //
6.749999999999972689e-01,3.405581808754325479e-01,-8.955195314513393345e-01, //
6.833333333333305726e-01,3.357094955332409203e-01,-8.967606842995115013e-01;

  int k_data1_limit = data1.rows()*2;
  int k_data2_limit = data2.rows()*2;
  int k_data3_limit = data3.rows()*2;
  double dt = (data1.row(1)(0)-data1.row(0)(0))/2;

  // Create the keys we need for this simple example
  static Symbol strokeparam1('s', 1);
  static Symbol p1('x', 0);
  static Symbol strokeparam2('s', 2);
  static Symbol p2('x', k_data1_limit);
  static Symbol strokeparam3('s', 3);
  static Symbol p3('x', k_data1_limit+k_data2_limit);

  // create a measurement for both factors (the same in this case)
  auto position_noise =
      noiseModel::Diagonal::Sigmas(Vector2(0.2, 0.2));  // 2cm std on x,y

  SlnStrokeExpression stroke1(p1, strokeparam1);
  SlnStrokeExpression stroke2(p2, strokeparam2);
  SlnStrokeExpression stroke3(p3, strokeparam3);

  // For loop to create factors for each position
  for (int k = 0; k < k_data1_limit; k++) {
    graph.add(stroke1.pos_integration_factor(k, dt));
  }
  for (int k = k_data1_limit; k < k_data1_limit+k_data2_limit; k++) {
    graph.add(stroke2.pos_integration_factor(k, dt));
  }
  for (int k = k_data1_limit + k_data2_limit; k < k_data1_limit + k_data2_limit+k_data3_limit; k++) {
    graph.add(stroke3.pos_integration_factor(k, dt));
  }

  // For loop to place priors at data/measured points
  for (int k = 0; k < data1.rows(); k++) {
    // this is following c++ way to cast to a type
    // we set timestep equal to the time at row(k)/dt
    size_t timestep = static_cast<size_t>(data1.row(k)(0) / dt);
    // now we check if timestep*dt is equal to the data time in row k
    assert_equal(timestep * dt, data1.row(k)(0));
    // does the assert equal ensure that ONLY matching timesteps get a prior?
    graph.emplace_shared<gtsam::PriorFactor<gtsam::Vector2>>(
        gtsam::symbol('x', timestep), data1.row(k).tail<2>(), position_noise);
        // TODO: potentially replace with 2*k to place at each actual point
  }
  for (int k = 0; k < data2.rows(); k++) {
    // this is following c++ way to cast to a type
    size_t timestep = static_cast<size_t>(data2.row(k)(0) / dt);
    assert_equal(timestep * dt, data2.row(k)(0));
    graph.emplace_shared<gtsam::PriorFactor<gtsam::Vector2>>(
        gtsam::symbol('x', timestep), data2.row(k).tail<2>(), position_noise);
  }
  for (int k = 0; k < data3.rows(); k++) {
    // this is following c++ way to cast to a type
    size_t timestep = static_cast<size_t>(data3.row(k)(0) / dt);
    assert_equal(timestep * dt, data3.row(k)(0));
    graph.emplace_shared<gtsam::PriorFactor<gtsam::Vector2>>(
        gtsam::symbol('x', timestep), data3.row(k).tail<2>(), position_noise);
  }

  // Print
  // graph.print("Factor Graph:\n");

  // Create (deliberately inaccurate) initial estimate
  Values initialEstimate;
  Vector6 sp1;
  sp1 << -0.2, 0.4, 10*M_PI/180, 0*M_PI/180, 0.5, -1.8;
  initialEstimate.insert(strokeparam1, sp1);
  Vector6 sp2;
  sp2 << -0.3, 0.5, 0*M_PI/180, -10*M_PI/180, 0.4, -1.5;
  initialEstimate.insert(strokeparam2, sp2);
  Vector6 sp3;
  sp3 << -0.3, 0.5, 0*M_PI/180, -10*M_PI/180, 0.4, -1.5;
  initialEstimate.insert(strokeparam3, sp3);

  // TODO: initialize this based on data
  for (int k = 0; k <= k_data1_limit+k_data2_limit+k_data3_limit; k++) {
    initialEstimate.insert(gtsam::symbol('x', k), Vector2(0.0, 0.0));
  }

  NonlinearFactorGraph graphLM = graph;
  // Optimize using Levenberg-Marquardt optimization. The optimizer
  // accepts an optional set of configuration parameters, controlling
  // things like convergence criteria, the type of linear system solver
  // to use, and the amount of information displayed during optimization.
  // Here we will use the default set of parameters.  See the
  // documentation for the full set of parameters.
  LevenbergMarquardtParams paramsLM;
  paramsLM.setMaxIterations(10000);
  paramsLM.setlambdaUpperBound(1e15);
  paramsLM.setVerbosity(
      "ERROR");  // SILENT, TERMINATION, ERROR, VALUES, DELTA, LINEAR
  LevenbergMarquardtOptimizer optimizerLM(graphLM, initialEstimate, paramsLM);
  Values resultLM = optimizerLM.optimize();

  //resultLM.print("Final Result:\n");

  // Create the stroke
  {  // const SlnStroke stroke(xy, t0, D, theta1, theta2, sigma, mu);
    Vector6 params1 = resultLM.at<Vector6>(strokeparam1);
    Point2 xy1 = resultLM.at<Point2>(p1);
    Point2 xy1_0 = SlnStroke (Point2::Zero(), params1).position(0,dt);
    std::cout << xy1_0 << std::endl;
    const SlnStroke stroke1(xy1-xy1_0, params1);
    std::ofstream myfile1;
    myfile1.open("stroke1_gtsam.csv");
    myfile1 << "time,x,y\n";
    for (int k = 0; k < k_data1_limit; k++) {
      double k_t = k * dt;
      Point2 pt1 = stroke1.position(k_t, dt);
      myfile1 << k_t << "," << pt1(0) << "," << pt1(1) << "\n";
    }
    myfile1.close();

    Vector6 params2 = resultLM.at<Vector6>(strokeparam2);
    Point2 xy2 = resultLM.at<Point2>(p2);
    Point2 xy2_0 = SlnStroke (Point2::Zero(), params2).position(k_data1_limit*dt,dt);
    const SlnStroke stroke2(xy2-xy2_0, params2);
    std::ofstream myfile2;
    myfile2.open("stroke2_gtsam.csv");
    myfile2 << "time,x,y\n";
    for (int k = k_data1_limit; k < k_data1_limit + k_data2_limit; k++) {
      double k_t = k * dt;
      Point2 pt2 = stroke2.position(k_t, dt);
      myfile2 << k_t << "," << pt2(0) << "," << pt2(1) << "\n";
    }
    myfile2.close();

    Vector6 params3 = resultLM.at<Vector6>(strokeparam3);
    Point2 xy3 = resultLM.at<Point2>(p3);
    Point2 xy3_0 = SlnStroke (Point2::Zero(), params3).position((k_data1_limit+k_data2_limit)*dt,dt);
    const SlnStroke stroke3(xy3-xy3_0, params3);
    std::ofstream myfile3;
    myfile3.open("stroke3_gtsam.csv");
    myfile3 << "time,x,y\n";
    for (int k = k_data1_limit + k_data2_limit; k < k_data1_limit + k_data2_limit + k_data3_limit; k++) {
      double k_t = k * dt;
      Point2 pt3 = stroke3.position(k_t, dt);
      myfile3 << k_t << "," << pt3(0) << "," << pt3(1) << "\n";
    }
    myfile3.close();
  }

  graph.saveGraph("tstSLN.dot", resultLM);

  // Calculate and print marginal covariances for all variables
  cout.precision(2);
  Marginals marginals(graph, resultLM, Marginals::Factorization::QR);
  cout << "p1 covariance:\n" << marginals.marginalCovariance(p1) << endl;
  cout << "strokeparam1 covariance:\n"
       << marginals.marginalCovariance(strokeparam1) << endl;
  cout << "p2 covariance:\n" << marginals.marginalCovariance(p2) << endl;
  cout << "strokeparam2 covariance:\n"
       << marginals.marginalCovariance(strokeparam2) << endl;
  cout << "p3 covariance:\n" << marginals.marginalCovariance(p3) << endl;
  cout << "strokeparam3 covariance:\n"
       << marginals.marginalCovariance(strokeparam3) << endl;
}

/* ************************************************************************* */
int main() {
  TestResult tr;
  return TestRegistry::runAllTests(tr);
}
