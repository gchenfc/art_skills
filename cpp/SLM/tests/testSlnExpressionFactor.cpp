/* ----------------------------------------------------------------------------

 * GTSAM Copyright 2010, Georgia Tech Research Corporation,
 * Atlanta, Georgia 30332-0415
 * All Rights Reserved
 * Authors: Frank Dellaert, et al. (see THANKS for the full author list)

 * See LICENSE for the license information

 * -------------------------------------------------------------------------- */

/**
 *  @file  testAvoidIndeterminateLinSys.cpp
 *  @author Juan-Diego Florez
 *  @author Gerry Chen
 **/

#include <CppUnitLite/TestHarness.h>
#include <gtsam/base/Vector.h>

#include <vector>

#include "../SlnStrokeExpression.h"

// We will also try this using an expression factor graph:
#include <gtsam/nonlinear/ExpressionFactorGraph.h>
#include <gtsam/slam/expressions.h>

// Each variable in the system (poses and landmarks) must be identified with a
// unique key. We can either use simple integer keys (1, 2, 3, ...) or symbols
// (X1, X2, L1). Here we will use Symbols
#include <gtsam/inference/Symbol.h>

// Finally, once all of the factors have been added to our factor graph, we will
// want to solve/optimize to graph to find the best (Maximum A Posteriori) set
// of variable values. GTSAM includes several nonlinear optimizers to perform
// this step. Here we will use the common Levenberg-Marquardt solver
#include <gtsam/nonlinear/LevenbergMarquardtOptimizer.h>
// Should the LM optimizer fail, we will use the GaussNewton optimizer, as it
// will error out if the system is indeterminate.
#include <gtsam/nonlinear/GaussNewtonOptimizer.h>

// Once the optimized values have been calculated, we can also calculate the
// marginal covariance of desired variables
#include <gtsam/nonlinear/Marginals.h>

using namespace std;
using namespace gtsam;
using namespace art_skills;

TEST(ExpressionSlnFactor, ILS) {
  // 1. Create a factor graph container and add factors to it
  ExpressionFactorGraph graph;

  // Create the keys we need for this simple example
  static Symbol strokeparam1('s', 1), strokeparam2('s', 2);
  static Symbol p1('x', 1), p2('x', 2);

  // Matrix for t, x, y, reference for each position factor
  Eigen::Matrix<double, 31, 3> data1;
  // TODO: import data from csv file generated by python script
  data1 << 0.000000000000000000e+00, 3.254897368664543267e-01,
      -8.936601621630331227e-01,  //
      1.666666666666660052e-02, 3.291453697577698678e-01,
      -8.852161029552397808e-01,  //
      2.499999999999990077e-02, 3.325515378590233051e-01,
      -8.787672389395526640e-01,  //
      3.333333333333320103e-02, 3.359679291751946351e-01,
      -8.703859355971451661e-01,  //
      4.166666666666650476e-02, 3.399923931724491144e-01,
      -8.602826055064219934e-01,  //
      4.999999999999980155e-02, 3.442824786600893194e-01,
      -8.480163473642363670e-01,  //
      5.833333333333309834e-02, 3.491627944160899943e-01,
      -8.333700759417705939e-01,  //
      6.666666666666640206e-02, 3.539444568538996361e-01,
      -8.171722977308741864e-01,  //
      7.499999999999970579e-02, 3.592159525538891618e-01,
      -7.986980555707734464e-01,  //
      8.333333333333300952e-02, 3.650546213240065674e-01,
      -7.787279749159550235e-01,  //
      9.166666666666629937e-02, 3.714736542000802166e-01,
      -7.570136703552537982e-01,  //
      9.999999999999960310e-02, 3.778634091460778555e-01,
      -7.333904140887657075e-01,  //
      1.083333333333329068e-01, 3.843281155915927449e-01,
      -7.087376395403870433e-01,  //
      1.166666666666661967e-01, 3.909623919130325032e-01,
      -6.824655080692988429e-01,  //
      1.249999999999995004e-01, 3.974843175627018055e-01,
      -6.555879713420276200e-01,  //
      1.333333333333328041e-01, 4.039229239569012142e-01,
      -6.276668544291764684e-01,  //
      1.416666666666661079e-01, 4.105347405162689256e-01,
      -5.992839591518326348e-01,  //
      1.499999999999994116e-01, 4.170243715585888467e-01,
      -5.709676427131310517e-01,  //
      1.583333333333327153e-01, 4.225962714348362459e-01,
      -5.424340160626357488e-01,  //
      1.666666666666660190e-01, 4.286362937160109743e-01,
      -5.141503176252475438e-01,  //
      1.749999999999992950e-01, 4.343193225662036472e-01,
      -4.862841172426772829e-01,  //
      1.833333333333325987e-01, 4.388840687436094123e-01,
      -4.590381204102663704e-01,  //
      1.916666666666659025e-01, 4.427400928215209919e-01,
      -4.330911887270484373e-01,  //
      1.999999999999992062e-01, 4.457518663108581691e-01,
      -4.092233080346499019e-01,  //
      2.083333333333325099e-01, 4.483554727983301014e-01,
      -3.883470340886382433e-01,  //
      2.166666666666658136e-01, 4.505788138762804040e-01,
      -3.709451157561682866e-01,  //
      2.249999999999991174e-01, 4.521774015580295458e-01,
      -3.582143602029230767e-01,  //
      2.333333333333323933e-01, 4.540392733371415579e-01,
      -3.502929538788304153e-01,  //
      2.416666666666656971e-01, 4.553027656528993994e-01,
      -3.465550328228148569e-01,  //
      2.499999999999990008e-01, 4.569055513590115636e-01,
      -3.463931905575849957e-01;  //

  Eigen::Matrix<double, 26, 3> data2;
  data2 << 2.583333333333323045e-01, 4.597726452772731287e-01,
      -3.480442627829090085e-01,  //
      2.666666666666656083e-01, 4.637466414709245366e-01,
      -3.511420191924676804e-01,  //
      2.749999999999989120e-01, 4.694712239202033510e-01,
      -3.549814288240396021e-01,  //
      2.833333333333322157e-01, 4.778600896501850603e-01,
      -3.592088052046040758e-01,  //
      2.916666666666655194e-01, 4.883024542988759764e-01,
      -3.639965914814113912e-01,  //
      2.999999999999988232e-01, 5.007569016599718870e-01,
      -3.694741496099679390e-01,  //
      3.083333333333321269e-01, 5.151484245725873601e-01,
      -3.761071136131695081e-01,  //
      3.166666666666654306e-01, 5.305850612123014232e-01,
      -3.835630095099867853e-01,  //
      3.249999999999987343e-01, 5.473633949232163953e-01,
      -3.924891186442278634e-01,  //
      3.333333333333320381e-01, 5.648703455475585500e-01,
      -4.013361775672120713e-01,  //
      3.416666666666652863e-01, 5.826855123717972207e-01,
      -4.111466170624401562e-01,  //
      3.499999999999985900e-01, 6.002228458510880937e-01,
      -4.215751605844063610e-01,  //
      3.583333333333318937e-01, 6.176110564609568199e-01,
      -4.327883014910600679e-01,  //
      3.666666666666651975e-01, 6.343934379849950345e-01,
      -4.448959022356647752e-01,  //
      3.749999999999985012e-01, 6.504811847326529284e-01,
      -4.573921175879326340e-01,  //
      3.833333333333318049e-01, 6.658590651729233700e-01,
      -4.711609448990483617e-01,  //
      3.916666666666651087e-01, 6.799793643641809382e-01,
      -4.858631072075896284e-01,  //
      3.999999999999984124e-01, 6.928587089667841425e-01,
      -5.013580801120272046e-01,  //
      4.083333333333317161e-01, 7.048465505846475132e-01,
      -5.179127578101864193e-01,  //
      4.166666666666650198e-01, 7.149582393679007053e-01,
      -5.347979029017730923e-01,  //
      4.249999999999983236e-01, 7.237916728324097493e-01,
      -5.525162038884621207e-01,  //
      4.333333333333316273e-01, 7.311118922125394715e-01,
      -5.704550933488865549e-01,  //
      4.416666666666649310e-01, 7.368061974258918179e-01,
      -5.887103193793614686e-01,  //
      4.499999999999982347e-01, 7.412459779213161903e-01,
      -6.071502256470979741e-01,  //
      4.583333333333315385e-01, 7.450023736799762375e-01,
      -6.252183404378520715e-01,  //
      4.666666666666647867e-01, 7.459270263188526595e-01,
      -6.434319707583902037e-01;  //

  // create a measurement for both factors (the same in this case)
  auto position_noise =
      noiseModel::Diagonal::Sigmas(Vector2(0.01, 0.01));  // 2cm std on x,y

  SlnStrokeExpression stroke1(p1, strokeparam1);
  SlnStrokeExpression stroke2(p2, strokeparam2);
  double dt = 0.0042;
  // For loop to create factors for each position
  for (int k = 0; k < 60; k++) {
    graph.add(stroke1.pos_integration_factor(k, dt));
  }
  for (int k = 0; k < 60; k++) {
    graph.add(stroke2.pos_integration_factor(k, dt));
  }
  // For loop to place priors at data/measured points
  for (int k = 0; k < data1.rows(); k++) {
    // this is following c++ way to cast to a type
    size_t timestep = static_cast<size_t>(data1.row(k)(0) / dt);
    assert_equal(timestep * dt, data1.row(k)(0));
    graph.emplace_shared<gtsam::PriorFactor<gtsam::Vector2>>(
        gtsam::symbol('x', timestep), data1.row(k).tail<2>(), position_noise);
  }
  for (int k = 0; k < data2.rows(); k++) {
    // this is following c++ way to cast to a type
    size_t timestep = static_cast<size_t>(data2.row(k)(0) / dt);
    assert_equal(timestep * dt, data2.row(k)(0));
    graph.emplace_shared<gtsam::PriorFactor<gtsam::Vector2>>(
        gtsam::symbol('x', timestep), data2.row(k).tail<2>(), position_noise);
  }

  // Print
  // graph.print("Factor Graph:\n");

  // Create (deliberately inaccurate) initial estimate
  Values initialEstimate;
  Vector6 sp1, sp2;
  sp1 << 0, 0.5, 0, 0, 0.4, -1.8;
  initialEstimate.insert(strokeparam1, sp1);
  sp2 << 0, 0.4, 0, 0, 0.4, -1.8;
  initialEstimate.insert(strokeparam2, sp2);

  // TODO: initialize this based on data
  for (int k = 0; k <= 60; k++) {
    initialEstimate.insert(gtsam::symbol('x', k), Vector2(0.0, 0.0));
    initialEstimate.insert(gtsam::symbol('y', k), Vector2(0.0, 0.0));
  }

  NonlinearFactorGraph graphLM = graph;
  // Optimize using Levenberg-Marquardt optimization. The optimizer
  // accepts an optional set of configuration parameters, controlling
  // things like convergence criteria, the type of linear system solver
  // to use, and the amount of information displayed during optimization.
  // Here we will use the default set of parameters.  See the
  // documentation for the full set of parameters.
  LevenbergMarquardtParams paramsLM;
  paramsLM.setMaxIterations(1000);
  paramsLM.setVerbosity(
      "SILENT");  // SILENT, TERMINATION, ERROR, VALUES, DELTA, LINEAR
  LevenbergMarquardtOptimizer optimizerLM(graphLM, initialEstimate, paramsLM);
  Values resultLM = optimizerLM.optimize();

  resultLM.print("Final Result:\n");

  graph.saveGraph("tstSLN.dot", resultLM);

  // Calculate and print marginal covariances for all variables
  cout.precision(2);
  Marginals marginals(graph, resultLM, Marginals::Factorization::QR);
  cout << "p1 covariance:\n" << marginals.marginalCovariance(p1) << endl;
  cout << "strokeparam1 covariance:\n"
       << marginals.marginalCovariance(strokeparam1) << endl;
  cout << "p2 covariance:\n" << marginals.marginalCovariance(p2) << endl;
  cout << "strokeparam2 covariance:\n"
       << marginals.marginalCovariance(strokeparam2) << endl;
}

/* ************************************************************************* */
int main() {
  TestResult tr;
  return TestRegistry::runAllTests(tr);
}
